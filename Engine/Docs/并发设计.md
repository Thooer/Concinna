# **Concinna Engine: Cap.Concurrency V4.0 设计**
**基于过程宏与 Trait 策略的自动化无锁容器工厂**

## **1. 核心理念：声明式并发 (Declarative Concurrency)**

在 Nova V3.1 中，我们通过复杂的 C++ 模板组合策略。在 Concinna 中，我们利用 Rust 的宏系统，允许开发者通过**属性标签**声明所需的并发特性，编译器自动生成经过微架构优化的代码。

**目标：**
1.  **自动化缓存防御：** 自动计算并插入 Padding，防止伪共享 (False Sharing)，无需手动写 `_pad: [u8; 64]`。
2.  **策略化行为：** 通过 Trait 组装等待策略（Spin/Park）和存储策略（Fixed/Dynamic）。
3.  **静态检查：** 在编译期拦截非法的策略组合（如 SPSC 用于多线程写入）。

---

## **2. 架构设计：三层抽象**

### **Layer 1: 策略定义 (The Policy Traits)**
定义无锁结构的行为原子。

```rust
// 等待策略：决定当队列满/空时做什么
pub trait WaitPolicy {
    fn wait(&self);
    fn notify(&self);
}

// 存储策略：决定数据存哪里
pub trait StoragePolicy<T> {
    unsafe fn get_unchecked(&self, index: usize) -> &T;
    unsafe fn write_unchecked(&self, index: usize, value: T);
    fn capacity(&self) -> usize;
}

// 回收策略：决定何时释放节点 (Epoch, Hazard, None)
pub trait ReclaimPolicy { ... }
```

### **Layer 2: 布局生成器 (The Layout Macros)**
这是“自动化”的核心。使用过程宏自动生成内存布局，强制执行 **"Read-Write 隔离"** 和 **"Cache Line 对齐"**。

**宏定义示例：**
```rust
#[proc_macro_attribute]
pub fn concurrency_model(attr: TokenStream, item: TokenStream) -> TokenStream {
    // 解析属性：type="SPSC", padding="True", align="128"
    // 自动生成带有 Padding 字段的 Struct
    // 自动实现 Send/Sync
}
```

### **Layer 3: 容器实现 (The Implementation)**
基于上述两层生成的具体容器（WorkStealingDeque, MPMCQueue 等）。

---

## **3. 详细设计：自动化工厂实战**

我们不再手动编写 `struct ChaseLevDeque`，而是定义它的**原型**，让宏生成最终代码。

### **3.1 示例：定义一个 SPSC 队列**

开发者只需写：

```rust
#[concurrency_model(
    model = "SPSC",          // 单生产单消费
    storage = "Bounded",     // 固定大小环形缓冲
    padding = "CacheLine",   // 自动填充缓存行
    sync = "Atomic"          // 使用原子操作
)]
pub struct CommandQueue<T>;
```

**宏展开后的代码（自动生成）：**

```rust
#[repr(C, align(128))] // 结构体整体对齐，防止跨页
pub struct CommandQueue<T> {
    // --- Read-Mostly Area (常量区) ---
    buffer: *mut T,
    capacity: usize,
    mask: usize,
    
    // --- Padding 1: 隔离常量与生产者 ---
    _pad0: [u8; 64], 

    // --- Producer Area (仅生产者写) ---
    head: AtomicUsize, // 生产者游标
    
    // --- Padding 2: 隔离生产者与消费者 (核心防御) ---
    // 防止 head 和 tail 在同一缓存行导致乒乓效应
    _pad1: [u8; 64], 

    // --- Consumer Area (仅消费者写) ---
    tail: AtomicUsize, // 消费者游标
    
    // --- Padding 3: 尾部保护 ---
    _pad2: [u8; 64],
}

// 自动实现标记 Trait
unsafe impl<T: Send> Send for CommandQueue<T> {}
unsafe impl<T: Send> Sync for CommandQueue<T> {}
```

### **3.2 示例：定义工作窃取队列 (Work-Stealing Deque)**

这是 `Sys.Job` 的核心。

```rust
#[concurrency_model(
    model = "WorkStealing",  // 头部 LIFO (Owner), 尾部 FIFO (Stealer)
    storage = "Dynamic",     // 支持动态扩容 (Chunked Linked List)
    reclaim = "Epoch"        // 使用 Epoch 内存回收
)]
pub struct JobDeque<T>;
```

**宏的智能逻辑：**
1.  检测到 `WorkStealing` 模型，自动生成 `push_bottom`, `pop_bottom` (Owner) 和 `steal` (Stealer) 方法。
2.  检测到 `Dynamic` 存储，自动注入 `AtomicPtr<Buffer>` 替代固定数组，并生成扩容逻辑。
3.  检测到 `Epoch`，自动注入 `GlobalEpoch` 引用。

---

## **4. 核心 Trait 体系 (Foundation/Cap/Concurrency/API)**

为了让宏生成的代码能通过类型检查，我们需要一套强大的 Trait 约束。

### **4.1 `ConcurrentQueue<T>` Trait**
所有生成的队列都必须实现此接口，以便 `Sys` 层统一调用。

```rust
pub trait ConcurrentQueue<T> {
    // 尝试入队 (非阻塞)
    fn try_push(&self, item: T) -> Result<(), T>;
    
    // 尝试出队 (非阻塞)
    fn try_pop(&self) -> Option<T>;
    
    // 批量操作 (优化屏障开销)
    fn bulk_push<I: Iterator<Item=T>>(&self, iter: I, count: usize) -> usize;
}
```

### **4.2 `Stealable<T>` Trait**
专用于任务调度器。

```rust
pub trait Stealable<T> {
    fn steal(&self) -> StealResult<T>; // Success, Empty, Retry
}
```

---

## **5. 移植 Nova V3.1 的关键算法**

利用 Rust 的特性，我们可以比 C++ 写得更安全。

### **5.1 优化：原子操作的 Ordering**
在 C++ 中，开发者容易混淆 `memory_order_acquire` 和 `release`。
在 Rust 中，我们可以通过 Trait 封装，强制正确性。

```rust
// 封装原子访问策略
trait AtomicAccess {
    fn load_acquire(&self) -> usize;
    fn store_release(&self, val: usize);
}

// 宏生成的代码会自动使用正确的 Ordering，
// 开发者无法在业务逻辑中写出错误的 Ordering。
```

### **5.2 优化：False Sharing 检测**
我们可以编写一个 **编译期检查 (Const Assert)** 或 **运行时测试**，验证宏生成的布局偏移量。

```rust
#[test]
fn verify_padding() {
    let q = CommandQueue::<i32>::new(1024);
    let base = &q as *const _ as usize;
    let head = &q.head as *const _ as usize;
    let tail = &q.tail as *const _ as usize;
    
    // 强制断言 head 和 tail 不在同一个 Cache Line (64 bytes)
    assert!((head / 64) != (tail / 64));
}
```

---

## **6. 模块规划与开发路径**

### **Phase 1: 宏基础设施 (`Derive`)**
*   开发 `lang_derive` crate 中的 `concurrency_model` 过程宏。
*   实现布局计算逻辑：根据 `cfg(target_arch)` 决定 Padding 大小（x64=64, M1=128）。

### **Phase 2: 基础策略实现 (`Cap.Concurrency`)**
*   实现 `SpinBackoff`, `YieldBackoff`。
*   实现 `BoundedBuffer` (Power of 2 ring buffer)。

### **Phase 3: 核心容器生成**
*   **`MPSCQueue`**: 用于 `Sys.Task` 的命令提交（多线程提交，单线程执行）。
*   **`SPSCQueue`**: 用于 `Sys.RHI` 的资源上传（独立上传线程）。
*   **`ChaseLevDeque`**: 用于 `Sys.Job` 的任务调度。

### **Phase 4: 调度器集成 (`Sys.Job`)**
*   将 `Sys.Job` 的 `Worker` 结构体内部的队列替换为宏生成的 `JobDeque`。

---

## **7. 总结：为什么这比 C++ 更好？**

1.  **所见即所得的布局控制：** 在 C++ 中，你需要小心翼翼地计算 `char pad[64 - sizeof(T)%64]`。在 Rust 中，宏替你完成了所有数学计算，并保证跨平台一致性。
2.  **强制安全性：** 宏生成的代码可以自动添加 `PhantomData<*mut T>`，确保 `Send/Sync` 的正确性，防止用户在多线程环境中误用非线程安全的容器。
3.  **极简 API：** Sim 层或 Sys 层的开发者只需要看属性标签（`model="SPSC"`），就能一眼看出这个队列的性能特征和用途，无需深入阅读模板代码。

这是 **Concinna "最高控制力"** 哲学的完美体现：**用编译器（宏）来管理硬件细节，让人类专注于策略。**