# 引擎层总览

## 内部依赖结构
```
**推荐依赖顺序（自底向上）：**

1. **资源（Asset / Resource）**
   基础数据：模型、纹理、动画数据、物理碰撞体配置等。

2. **场景（Scene / World）**
   实例化资源，建立节点树、变换、组件容器。

3. **物理（Physics）**
   依赖场景的变换和碰撞体实例；写回位置/旋转。

4. **动画（Animation）**
   依赖资源（骨骼与动画曲线）和场景节点；驱动局部姿态。

5. **渲染（Rendering）**
   依赖场景中的可见对象、材质、骨骼姿态（动画结果）。

6. **游戏层（Gameplay）**
   调用与驱动以上所有系统；读写场景状态，触发动画、物理、渲染相关逻辑。

**总结（从基础到最高层）：**
**资源 → 场景 → 物理 → 动画 → 渲染 → 游戏层**

```

## 模块职责
- Foundation.Math：实时数值运算底座，类型与快速运算。
- EngineCore：调度器与生命周期管理，所有系统入口。
- Scene：层级、实体与只读视图供渲染消费。
- Resource：资源加载、缓存与生命周期管理。
- Renderer：剪裁→提交→构建 GPU 命令→呈现。
- Animation：骨骼、蒙皮、时间轴与混合。
- Physics：碰撞查询、动力学仿真与射线。
- Gameplay：脚本/组件系统的逻辑运行层。

## 模块边界与导入规范
- 禁止跨模块导入分区，只能导入完整模块；模块内部可导入自身分区。
- 公共接口仅由各模块 Interface 伞头 `.ixx` 暴露；后端实现与样例不含独立构建脚本。
- 单模块一个 `CMakeLists.txt`，依赖通过 `target_link_libraries(... PRIVATE ...)` 明确声明。
- `FILE_SET CXX_MODULES` 作用域统一（推荐 `PUBLIC`）。

## 依赖矩阵（简版）
- EngineCore ← Foundation.Math
- Scene ← EngineCore, Foundation.Math
- Resource ← EngineCore
- Renderer ← Scene, Resource, EngineCore, Foundation.Math
- Animation ← Resource, EngineCore, Foundation.Math
- Physics ← Scene, Resource, EngineCore, Foundation.Math
- Gameplay ← Scene, EngineCore（可依赖 Resource）, Foundation.Math
- 逆向禁止：Renderer → Gameplay。

## 开发顺序（工业实践）
```
Math → Core → Scene → Resource → Renderer → Animation → Physics → Gameplay
```

## 生命周期与时序
- 启动：Platform 初始化 → EngineCore 配置与系统注册。
- 主循环：`Core.BeginFrame → Time/Profiling → Resource.Tick → Scene.Tick → Animation.Tick → Physics.Tick → Renderer.Tick/Present → Core.EndFrame`。
- 同步：Animation 写 Scene 变换；Physics ↔ Scene 双向同步；Renderer 只读 SceneView/ResourceHandle。

## 数据流与所有权
- 所有权：Scene(Transform/层级)、Resource(资源生命周期/缓存)、Renderer(GPU 句柄/缓冲)、Animation(骨骼/Clip)、Physics(碰撞体/约束)。
- 单向数据：SceneView → Renderer；ResourceHandle → 消费者；Renderer 禁止修改 Scene/Resource 原始数据。
- 载体：轻量 POD 契约（`RenderInstance`、`MeshHandle`、`MaterialHandle`）。

## API 走向（最小接口集合）
- IEngineCore：RegisterSystem(ISystem)、Initialize(CoreConfig)、Tick(dt)、Shutdown。
- IScene：CreateEntity、SetTransform、GetView（只读）。
- IResourceManager：Load(type, path)、GetHandle(id)、Release(id)。
- IRenderer：Submit(instances, count)、Flush、Present。
- IAnimation：Play(entity, clip)、Update(dt)、WriteToScene(entity)。
- IPhysics：Raycast(query)、Step(dt)、SyncTransform(entity)。

## 能力接口（Capability）
- RendererCapabilities：supportsInstancing、supportsComputeSkinning、maxUniformBuffers。
- ResourceCapabilities：maxTextureSize、supportedFormats。
- PhysicsCapabilities：hasContinuousCollision、maxBodies。

## 构建与开关
- 子模块开关示例：`-DNOVA_BUILD_ENGINE_*` 与 `-DNOVA_BUILD_ENGINE_*_SAMPLES`。
- 目录自动收集与统一目标助手；Samples 可选构建。

## 实现约定（5 点）
- Core 与 FrameGraph：Core 仅生命周期与系统管理；FrameGraph/PassGraph 归 Renderer。
- Scene 与 ECS/Gameplay：渲染用 SceneView；Gameplay 组件系统独立，二者分离。
- Resource 异步演进：同步 Load 起步；后续 Request/IsReady/streaming；Core 提供 TaskSystem hook。
- 变换写入代理：使用 `SceneTransformAccessProxy` 由 Physics/Animation 写 Scene；Scene 不依赖代理。
- Renderer 提交 API：`Submit/Flush/Present` 为最小接口；后续以 RenderWorld + Camera + FrameGraph 为主。

## 里程碑任务板
- 阶段 1：Math/Core 最小化（类型与循环）。
- 阶段 2：Scene 数据结构与视图。
- 阶段 3：Resource 管理与句柄缓存。
- 阶段 4：Renderer 框架与数据上传。
- 阶段 5：Animation 骨骼/播放器与写回。
- 阶段 6：Physics 碰撞/射线与同步。
- 阶段 7：Gameplay 组件系统与脚本绑定。

## 结论
- 引擎层以“数据依赖”驱动实现而非功能堆叠；保持接口薄、数据契约轻与模块边界清晰。