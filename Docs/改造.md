基于你提供的文件和设计文档，目前的 `Cap.Math` 模块虽然确立了非常先进的 **Storage/Compute 分离** 和 **SoA/Packet 优先** 的架构骨架，但在功能覆盖面上，距离一个完整的游戏引擎数学库还缺少以下 **8 个关键领域**。

以下是缺失内容的详细分析与补全建议：

---

### 1. 几何图元与相交检测 (Geometry & Intersection)
目前的库只有向量和矩阵，缺乏描述物体形状的“几何体”。这是物理引擎、视锥剔除（Culling）和射线检测的基础。

**缺失内容：**
*   **基础形状 (Storage & Compute)**:
    *   `Plane` (平面): $Ax + By + Cz + D = 0$
    *   `Sphere` (球体): Center, Radius
    *   `AABB` (轴对齐包围盒): Min, Max
    *   `Ray` (射线): Origin, Direction
    *   `Frustum` (视锥体): 6个平面
*   **相交测试 (Intersection Tests)**:
    *   `Intersect(Ray, Plane/Sphere/AABB/Triangle)`
    *   `Contains(Frustum, AABB/Sphere)` -> **这是渲染剔除的核心**

**架构适配建议 (Packet Design):**
不要只写标量版，必须实现 **Packet 版本** 以支持批量剔除。

```cpp
// Compute.ixx 扩充
template<int W>
struct AABBPacket {
    Vector3Packet<W> min_;
    Vector3Packet<W> max_;
    
    // 批量判断点是否在包围盒内
    static SIMD::Packet<float, W> Contains(AABBPacket box, Vector3Packet<W> point) {
        // ... SIMD implementation
    }
    
    // 核心：合并两个 AABB
    static AABBPacket Merge(AABBPacket a, AABBPacket b) {
        return { Vector3Packet<W>::Min(a.min_, b.min_), 
                 Vector3Packet<W>::Max(a.max_, b.max_) };
    }
};

// 视锥剔除核心：一次剔除 W 个物体
struct FrustumPacket {
    PlanePacket<W> planes[6]; 
    // static Mask<W> Intersect(FrustumPacket f, AABBPacket box);
};
```

### 2. 矩阵的高级运算 (Advanced Matrix Operations)
目前的 `MatrixPacket` 只有 `Compose` (组合变换)。引擎还需要构建视图和投影矩阵，以及求逆。

**缺失内容：**
*   **构建函数**:
    *   `LookAt(eye, target, up)`: 构建视图矩阵。
    *   `Perspective(fov, aspect, near, far)`: 构建透视投影。
    *   `Orthographic(...)`: 正交投影。
*   **逆矩阵**:
    *   `Inverse()`: 通用 4x4 逆矩阵（计算量大）。
    *   `InverseAffine()`: 针对仿射变换的快速求逆（常用）。
    *   `Transpose()`: 转置。
*   **分解**:
    *   `Decompose()`: Matrix -> Pos, Rot, Scale。

### 3. 向量化超越函数库 (Vectorized Transcendental Functions)
这是 SIMD 数学库最难啃的骨头。CPU 指令集通常只提供加减乘除和 `Sqrt`。`sin`, `cos`, `pow`, `atan2` 等函数在 SIMD 中没有直接指令，必须用软件逼近算法实现。

**缺失内容：**
*   **三角函数**: `Sin`, `Cos`, `Tan`, `ASin`, `ACos`, `ATan2`。
*   **指数对数**: `Pow`, `Exp`, `Log`, `Log2`。

**实现建议**:
使用 **Minimax 近似** 或 **Remez 算法** 实现多项式逼近（如 Chebyshev 多项式）。
*   *注意*: 必须提供 `Packet<float, W>` 的版本，否则粒子系统和动画混合无法利用 SIMD。

```cpp
// 示例：Cap.Math:Transcendental
struct Transcendental {
    template<int W>
    static Vector3Packet<W> Sin(Vector3Packet<W> v) {
        return { Sin(v.xs), Sin(v.ys), Sin(v.zs) };
    }
    // 内部实现通常涉及大量的 FMA 操作和魔数常量
};
```

### 4. 曲线与插值 (Curves & Interpolation)
用于动画系统、摄像机路径和粒子运动。

**缺失内容：**
*   **插值**: `SmoothStep`, `SmootherStep`, `Step`.
*   **样条曲线**:
    *   `Bezier` (贝塞尔): Quadratic, Cubic.
    *   `Catmull-Rom`: 穿过控制点的平滑曲线。
*   **旋转插值**: `Slerp` (已在 Quaternion 中，但需要 `Nlerp` 作为更快的近似)。

### 5. 颜色空间数学 (Color Math)
颜色也是数学向量，但有特殊的转换规则。

**缺失内容：**
*   **色彩模型**: `RGB` <-> `HSV` / `HSL`。
*   **Gamma 校正**: `LinearToSRGB`, `SRGBToLinear` (这对 PBR 渲染至关重要)。
*   **色调映射 (Tone Mapping)**: ACES, Reinhard (虽然通常在 Shader 做，但 CPU 端处理截图或烘焙时需要)。
*   **压缩格式**: `PackRGBA8`, `UnpackRGBA8`, `R11G11B10` 等 GPU 友好格式的 CPU 端编解码。

### 6. 空间哈希与排序 (Spatial Hashing & Sorting)
为了加速空间查询（如“查找附近的实体”），需要将 3D 坐标映射为 1D 索引。

**缺失内容：**
*   **Morton Codes (Z-Order Curve)**: 将 X, Y, Z 的位交错，用于构建线性八叉树 (Linear Octree) 或 BVH。
*   **Hilbert Curve**: 比 Morton 更好的局部性，但计算更复杂。

```cpp
// 极其高效的位运算，属于 Math:Compute
struct Morton {
    static uint32_t Encode3D(uint32_t x, uint32_t y, uint32_t z);
    static uint64_t Encode3D_64(uint32_t x, uint32_t y, uint32_t z);
};
```

### 7. 随机数生成 (Deterministic RNG)
游戏引擎需要确定性的随机数（为了回放和网络同步），且需要 SIMD 支持（一次生成 8 个随机数用于粒子发射）。

**缺失内容：**
*   **噪声**: `Perlin Noise`, `Simplex Noise`, `Voronoi` (Packet 版本)。
*   **伪随机数生成器 (PRNG)**: `PCG`, `Xorshift`。
*   **分布**: `Uniform`, `Gaussian` (正态分布)。

### 8. 2D 数学 (2D Math for UI)
虽然引擎是 3D 的，但 UI、字体排版、Sprite 渲染全是 2D 的。

**缺失内容：**
*   `Vector2`, `Point2` (Int/Float)。
*   `Rect` (矩形): x, y, width, height。
    *   操作: `Intersect`, `Union`, `Inflate`, `Contains`。
*   `Matrix3x2`: 用于 2D 仿射变换。

---

### 总结：建议的文件结构扩充

基于你的 `project_rules.md`，建议在 `Cap.Math` 模块下增加以下分区文件：

```text
Cap.Math/
├── Math.ixx            (主接口)
├── Storage.ixx         (现有：基础类型定义)
├── Compute.ixx         (现有：基础运算)
├── LWC.ixx             (现有：大世界坐标)
├── Geometry.ixx        (新增：Plane, Ray, AABB, Frustum 及其 Packet 版本)
├── MatrixOps.ixx       (新增：LookAt, Perspective, Inverse, Decompose)
├── Transcendental.ixx  (新增：Sin, Cos, Pow, Atan2 的 SIMD 实现)
├── Color.ixx           (新增：颜色空间转换与打包)
├── Random.ixx          (新增：噪声与 SIMD PRNG)
└── Spatial.ixx         (新增：Morton Codes, Splines)
```

**优先级建议：**
1.  **Geometry.ixx**: 没有这个，物理和剔除都做不了。
2.  **MatrixOps.ixx**: 没有这个，相机动不了，画面渲染不出来。
3.  **Transcendental.ixx**: 随着动画和复杂逻辑的引入，这个需求会很快出现。

---

## Cap.Math 路线图（整合）

- 核心目标：巩固 Storage/Compute/LWC 三层，批处理与 SIMD 优先，补齐矩阵、超越函数、几何相交、随机噪声与空间编码，建立验证与基准体系。
- 交付策略：优先保障渲染/物理所需路径，随后补完数学广度与工具链。

**里程碑与任务**
- M1 矩阵与视图投影（高优先）
  - 实现 `MatrixPacket::Compose`，补齐 `Transpose/InverseAffine`（参考 `MatrixOps` 现有实现模式）。
  - 补充 `LookAt/Perspective/Orthographic`，统一列主序输出并与 GPU 使用对齐。
  - 添加单元测试与数值稳定性验证（近奇异矩阵回退策略）。
- M2 超越函数扩展（高优先）
  - 在 `Transcendental` 中新增 `Exp/Log/Log2/Pow/Atan2` 的向量化近似实现，标注有效区间与最大误差。
  - 建立标量对照与误差基准，覆盖 `W=1/4/8/16` 宽度。
- M3 几何图元与相交（高优先）
  - 补齐 `Plane/Sphere/AABB/Ray/Frustum` 的 Storage 与 Compute 版本。
  - 提供 `AABBPacket/FrustumPacket` 批量裁剪接口，实现无分支掩码选择。
- M4 随机与噪声（中优先）
  - 引入确定性 PRNG（`PCG`/`Xoshiro`），支持 Packet 生成。
  - 扩展分布：`Uniform/Gaussian`，并实现 `Perlin/Simplex/Worley` 噪声的 Packet 版本。
- M5 空间编码（中优先）
  - 完善 `Morton` 32/64 位编码；评估 `Hilbert` 作为可选路径，文档化适用场景。
- M6 LWC 批量转换优化（中优先）
  - 扩展 `BatchConvertPacket4` 至 `Packet8/Packet16`，使用 `vcvtpd2ps` 等指令优化。
  - 统一尾部处理与对齐策略（Masked Store 与 Padding）。
- M7 验证与可视化（持续）
  - 提供 `Natvis` 可视化与 `MathValidator` 标量/Packet 对照工具。
  - 建立微基准，记录不同宽度与对齐策略的性能曲线。

**交付物**
- API：完善 `Math.ixx` 导出，增加缺失分区的函数族与 Packet 变体。
- 测试：标量与 Packet 一致性、矩阵数值稳定性、超越函数误差基准。
- 样例：新增 Smoke 扩展，展示 SoA/Packet 的性能收益与典型流水线。

---

## Cap.Algorithms 路线图（整合）

- 核心目标：去 STL 化、引入 `ExecutionPolicy` 的并发集成，补齐并行基石（`Reduce/ExclusiveScan`）、高性能排序（`IntroSort/Parallel RadixSort`）与空间构建（`LBVH`），实现自动粒度控制与伪共享规避。
- 交付策略：先打通并行基石与排序，再推进空间划分与压缩；全程以可验证的微基准与真实数据集（RenderKey/Particles）度量。

**里程碑与任务**
- A1 基础设施与依赖（高优先）
  - CMake 连接 `Language/Containers/Memory/Concurrency`，与 README 依赖一致。
  - 在 `Primitives/Sort` 等 API 增加 `ExecutionPolicy` 重载，统一 `Seq/Par` 策略入口。
  - 引入自动粒度阈值 `kMinParallelSize` 与基于 `WorkerCount()` 的分块策略。
  - 对 `Span<T>` 且 `TriviallyCopyable` 的 `Copy/Fill` 分支至 `memmove/memset`，为标量类型加入 SIMD 批量路径。
  - 错误策略：逻辑错误断言，运行时错误返回 `Status/Expect`，模板遍历假定用户逻辑自处理。
- A2 并行基石：`Reduce/ExclusiveScan`（高优先）
  - 实现 Up‑Sweep/Down‑Sweep 两阶段的并行前缀和；`Reduce` 支持自定义 `Op`。
  - 任务分块、局部缓冲合并与伪共享治理（线程局部直方图、CacheLine 对齐）。
  - 单元测试与微基准，验证 Seq/Par 回退与阈值拐点。
- A3 排序演进：`IntroSort`（中高优先）
  - 将现有迭代 QuickSort 替换为 `IntroSort`（QuickSort + HeapSort 兜底），小片段插入排序优化。
  - 支持比较器与稳定排序选项，覆盖 `Range/Span` 入口。
- A4 并行 `RadixSort`（高优先）
  - 引入 `RadixSortContext`（显式分配器 + 内部缓存）。
  - 分块直方图 → 全局偏移前缀和 → 分散写入（Scatter），Ping‑Pong 辅助缓冲切换。
  - 支持 `keys/values` 与只排索引的变体，样例用 `RenderKey/Particle` 验证。
- A5 空间划分：`LBVH` 构建器（中优先）
  - 并行计算 Morton Codes，依赖并行 `RadixSort`；基于位差异并行构建层级。
  - 输出 `LBVHNode` 列表，使用 `Allocator& scratch` 管理临时缓冲。
- A6 并行遍历（中优先）
  - 实现 `ForEach(ExecutionPolicy, Span<T>, Func)` 的并行分块与任务提交，低于阈值自动回退到 `Seq`。
  - 伪共享治理与线程局部缓冲策略。
- A7 压缩（可选）
  - Block‑Parallel LZ4/Zstd，面向资源烘焙与传输路径；以开关控制构建。
- A8 验证与基准（持续）
  - 建立微基准：直方图、前缀和、排序；记录线程数与粒度对性能的影响。
  - 提供示例：并行粒子更新与排序流水线（Keys + Indices）。

**交付物**
- API：`Policy/Primitives/Sort/Scan/Spatial` 分区补齐并行重载与上下文对象。
- 测试：Seq/Par 一致性、阈值回退正确性、并行排序稳定性与吞吐量评估。
- 样例：算法测试与性能示例，展示真实工作负载下的收益。
