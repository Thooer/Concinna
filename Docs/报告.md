画面不运动的根本原因是 **`Prm.Time` 模块在 Windows 平台下的时间计算发生了整数溢出**。

### 1. 问题分析

在日志中，你看到：
`[VK] UpdateCubes done angle=0.00 ...`

这意味着 `angle` 始终为 0。在 `Engine.App.src.main.rs` 中：
```rust
let t = now();
let angle = (delta_seconds(t0, t) as f32) * 0.8;
```
如果 `angle` 为 0，说明 `delta_seconds(t0, t)` 为 0，即 `t` 和 `t0` 相等。

查看 `Foundation.Prm.Time.Impl.Windows.Time.rs` 中的实现：

```rust
pub fn impl_now_ns() -> i64 {
    let mut c: i64 = 0;
    unsafe { QueryPerformanceCounter(&mut c as *mut i64); }
    let f = qpf();
    // 问题出在这里：
    c.saturating_mul(1_000_000_000).saturating_div(f)
}
```

*   `QueryPerformanceCounter` (`c`) 返回的是系统启动以来的 Tick 数。
*   `i64::MAX` 大约是 $9.22 \times 10^{18}$。
*   你试图将 `c` 乘以 `1,000,000,000` ($10^9$)。
*   只要 `c` 大于 $9.22 \times 10^9$，乘法就会溢出。
*   如果 CPU 频率（QPF）是 10MHz ($10^7$)，那么仅仅开机 **922 秒 (约 15 分钟)** 后，`c * 1_000_000_000` 就会超过 `i64` 的上限。
*   由于使用了 `saturating_mul`，结果被锁定在 `i64::MAX`。
*   因此，`t0` 和 `t` 都返回了相同的饱和值，导致 `delta` 为 0，画面静止。

### 2. 修复方案

需要使用 `u128` 进行中间计算以避免溢出，然后再转回 `i64`。

请修改 **`Foundation/Prm/Time/Impl/Windows/Time.rs`**：

```rust
// ... 前面的代码保持不变 ...

pub fn impl_now_ns() -> i64 {
    let mut c: i64 = 0;
    unsafe { QueryPerformanceCounter(&mut c as *mut i64); }
    let f = qpf();
    
    // 修复：使用 u128 避免乘法溢出
    let ticks = c as u128;
    let freq = f as u128;
    let ns = ticks.wrapping_mul(1_000_000_000) / freq;
    
    ns as i64
}

// ... 后面的代码保持不变 ...
```

### 3. 额外建议 (性能优化)

在 `Engine.App.src.main.rs` 的主循环中，你目前的逻辑是每一帧都重新加载模型文件：

```rust
// Engine.App.src.main.rs

// 每一帧都在做 IO 和 字符串解析
if let Some(m) = sys_rhi::load_model_vfs(&vfs, &path) { 
    if let Some(ref mut ctx) = dev {
        // 虽然这里有 check 避免重复上传 GPU，但上面的 load_model_vfs 依然产生了大量 CPU 开销
        let _ = ctx.upload_model(&m); 
        // ...
    }
}
```

虽然这不会导致画面静止，但会严重影响帧率。建议将模型加载移到循环外，或者在脚本层控制只在初始化时加载一次。

**修复后的预期结果：**
重新编译运行后，`angle` 将随时间变化，控制台日志中的 `angle` 值会变动，方块将开始旋转。