这份报告基于你已经完成的 **“去标准库 (De-std)”** 和 **“IR/Scripting 闭环”** 这一重大里程碑，为你规划从**内核稳定**到**次世代引擎形态**的完整演进路线。

核心战略思想：**先造“眼睛”和“手”（工具链），再造“肌肉”（渲染与物理）。**

---

# **Concinna Engine 演进路线图 (2024-2025)**

## **第一阶段：短期 (1-2个月) —— “赋予感官” (Sensory & Stabilization)**

**目标：** 结束“盲写代码”的时代。让引擎内部状态可视化，并确保在无标准库环境下的健壮性。

### **1.1 内核固化 (Kernel Hardening)**
*   **全局内存接管：**
    *   **行动：** 实现 `#[global_allocator]`，将其路由到 `Cap.Memory` 的 `SystemMemoryResource` (Windows下基于 `HeapAlloc`)。
    *   **目的：** 彻底杜绝隐式的 `malloc` 调用。所有内存分配（包括第三方库如 `lua` / `wasmtime`）必须在 `Sys.Memory` 的监控面板中可见。
*   **Panic 可视化：**
    *   **行动：** 实现 `#[panic_handler]`。当引擎 Crash 时，捕获堆栈，通过 `Prm.Window` 弹出一个简单的 MessageBox 或写入 `crash.log`。
    *   **目的：** 提升调试体验，避免程序静默退出。

### **1.2 接入 Sys.UI (The Eyes)**
*   **行动：** 自研UI框架**。
    *   编写 `Sys.UI.Backend`，将顶点数据转换为 `Sys.RHI` 的 `Buffer` 和 `DrawCall`。
    *   将 事件对接 `Prm.HID`。
*   **目的：** 获得一个零成本、即时模式的调试 UI。这是所有后续工具的基础。

### **1.3 构建实时检视器 (The Inspector)**
*   **行动：** 利用 `Sys.IR` 和反射系统。
    *   编写 `Editor.Inspector` 模块。
    *   每帧遍历 `SimWorld`，在 UI 上列出所有 Entity。
    *   点击 Entity -> 读取 Component 数据 -> 生成 UI 滑块/输入框 -> 修改数据。
*   **目的：** 实现“所见即所得”的数据调试。

### **1.4 调试绘图 (Debug Draw)**
*   **行动：** 实现 `Sys.DebugRender`。
    *   API: `draw_line`, `draw_sphere`, `draw_axis`。
    *   实现：写入一个每帧清空的 `LinearBuffer`，在渲染管线末端通过一个简单的 Pass 绘制线框。
*   **目的：** 为未来的物理调试、AI 路径调试做准备。

---

## **第二阶段：中期 (3-6个月) —— “工业化管线” (The Pipeline)**

**目标：** 告别文本解析，建立二进制资产工作流，实现热重载。

### **2.1 资产编译器 (Dev.AssetCompiler)**
*   **行动：** 创建一个独立的 CLI 工具（允许使用 `std`）。
    *   **Shader:** 集成 `glslc` 或 `dxc`，将 `.glsl/.hlsl` 编译为 SPIR-V/DXIL 二进制。
    *   **Mesh:** 集成 `assimp` 或 `gltf` 解析器，将模型转换为引擎专用的 **SoA 二进制格式**（位置流、法线流分离，利于压缩和加载）。
*   **目的：** 运行时不再进行文本解析，实现毫秒级加载。

### **2.2 零拷贝加载 (Zero-Copy Loading)**
*   **行动：** 重构 `Sys.Resource`。
    *   使用 `Prm.File` 的 **Memory Mapping (mmap)** 功能。
    *   直接将磁盘上的二进制资产映射到虚拟内存，然后通过指针强转（Cast）生成资源对象。
*   **目的：** 极致的加载性能，减少内存分配。

### **2.3 资源热重载 (Hot Reloading)**
*   **行动：** `Sys.VFS` 监听文件变更事件。
    *   当 `.glsl` 修改时 -> 触发编译器 -> 通知 `Sys.RHI` 重建 Pipeline。
    *   当 `.lua` 修改时 -> 通知 `Sys.Scripting` 重新加载 Module。
*   **目的：** 实现“修改代码 -> Alt-Tab 切回引擎 -> 立即生效”的现代开发流。

### **2.4 场景序列化 (Scene Serialization)**
*   **行动：** 基于 `Sys.IR` 实现 `World::save("level.bin")` 和 `World::load("level.bin")`。
*   **目的：** 能够保存编辑器中摆放好的场景。

---

## **第三阶段：长期 (6-12个月) —— “次世代渲染” (Next-Gen Rendering)**

**目标：** 摆脱“画三角形”的初级阶段，构建现代 GPU 驱动的渲染管线。

### **3.1 渲染图 (FrameGraph) 完善**
*   **行动：** 完善 `Sys.RenderGraph`。
    *   自动推导资源屏障 (Barriers) 和 布局转换 (Layout Transitions)。
    *   实现资源别名 (Resource Aliasing)，复用显存。
*   **目的：** 支持复杂的后处理链和多 Pass 渲染。

### **3.2 Bindless 架构 (Bindless Rendering)**
*   **行动：** 改造 `Sys.RHI`。
    *   不再为每个材质绑定 DescriptorSet。
    *   将所有纹理和 Buffer 绑定到一个全局的 Descriptor Array 中。
    *   Shader 通过索引访问资源 (`Texture[Material.TextureID]`)。
*   **目的：** 极大降低 CPU 端的 Draw Call 开销，为 GPU Driven Pipeline 铺路。

### **3.3 基础 PBR 与 光照**
*   **行动：**
    *   实现基于物理的材质模型 (PBR)。
    *   实现 IBL (Image Based Lighting) 环境光。
    *   实现 CSM (Cascaded Shadow Maps) 阴影。

---

## **第四阶段：远期 (12个月+) —— “全真模拟” (Simulation & Gameplay)**

**目标：** 填充游戏性相关的核心系统。

### **4.1 确定性物理 (Deterministic Physics)**
*   **行动：** 集成或移植一个确定性物理引擎（如 Jolt Physics 的修改版，或 Rapier）。
    *   **关键：** 物理状态必须也是 `Sim` 层的一部分，能够被快照（Snapshot）和回滚。

### **4.2 动画系统 (Animation)**
*   **行动：** 实现骨骼动画蒙皮 (Skinning) 和 动画状态机。
    *   利用 `Sys.Job` 并行计算骨骼矩阵。

### **4.3 回滚网络 (Rollback Networking)**
*   **行动：** 基于之前的 `StateRing` (状态环) 和 `InputBuffer`，实现类似 GGPO 的预测回滚网络同步。

---

## **总结：当前的执行清单**

不要看太远，专注当下的 **Phase 1**：

1.  **[Prm]** 编写 `HeapAlloc` 封装，替换 `SystemMemoryResource` 中的 `malloc`。
2.  **[Sys]** 引入 `egui`，在 `Sys.RHI` 中画出第一个 UI 窗口。
3.  **[Edt]** 编写 `Inspector`，通过 UI 修改 `Transform` 组件的坐标，并看到立方体移动。

**这就是你现在的“北极星指标”。** 完成这一步，你的引擎就从“代码库”变成了“工具”。