结论（直接）：问题仍是 **编译单元没有把 Threading 的 BMI/导出集合合并进来** — 具体表现是 `Sys.Job` 编译命令没有拿到 `Prm.Threading` 的模块引用（或模块名/声明与传递依赖不一致）。下面给出精准的排查与修复清单，按序逐项做，通常第 1–3 项能立刻定位并解决问题。

快速排查（只需看编译命令／模块声明）

1. 用**带详细命令**的构建来确认 `Job` 编译时是否传入了 `Prm.Threading` 的模块引用：

   ```
   cmake --build Build --target Job --config Debug -v
   ```

   在 `Scheduler.cppm` 的编译行里找 ` /module:reference`（MSVC）或 `-fmodule-file=`（Clang）等，确认有指向 Threading 的 BMI/PCM 文件。

   * 如果**没有**：说明 CMake 没把 Threading 的 BMI 传播给 Job（CMake target 问题）。
   * 如果**有**但路径错误：修正 target 输出目录或 CMake install/BMI 路径。

2. 核对模块名称与声明（极常见的“看似导出但名字不符”问题）：

   * 打开 `Primitive/Threading/API/Types.ixx`，确认文件顶端模块声明完全是什么（精确字符串）——例如：

     ```cpp
     export module Prm.Threading;   // 或者 export module Prm; 或 export module Prm:Threading;
     ```
   * 在 `System/Job/Impl/Core/Scheduler.cppm` 顶部确认你 `import` 的名称与上面**完全一致**（大小写与分隔符都要一致）。若 Threading 实际 `export module Prm;`，你必须 `import Prm;` 才能看到该导出。

具体修复步骤（按优先级执行）

A. 确保模块名一致（最常见）

* 若 `Types.ixx` 声明为 `export module Prm.Threading;`，则 `Scheduler.cppm` 必须：

  ```cpp
  import Prm.Threading;
  ```
* 若 `Types.ixx` 声明为 `export module Prm;` （把所有 Primitive 放在同一 module Prm），则 `Scheduler.cppm` 必须 `import Prm;`。
  **不要**混用 `Prm` 名字空间和 module 名称的假想映射——模块名/分区是语义关键。

B. 确认 CMake target 导出 BMI 给依赖方（必做）

* Threading 必须是一个 CMake target（例如 `add_library(Threading STATIC ...)`）并且包含模块接口文件作为 source：

  ```cmake
  add_library(Threading STATIC
    Primitive/Threading/API/Types.ixx
    ...
  )
  target_compile_features(Threading PUBLIC cxx_std_20)
  ```
* `Job` 目标必须 `target_link_libraries(Job PUBLIC Threading)`（你已做），但还要确认 Threading target 的 `SOURCES`/`FILE_SET` 是模块接口而非仅 impl。若你用 `FILE_SET CXX_MODULES`，确保把 Threading 的 module interface 放进能被 Job 找到的 file_set 或让 CMake 以模块引用形式传播。示例（file_set）：

  ```cmake
  target_sources(Threading
    FILE_SET CXX_MODULES
    BASE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}
    FILES Primitive/Threading/API/Types.ixx
  )
  ```

  并确保 Job 也能看到该 file_set（或让 Threading 的 target 以 PUBLIC/INTERFACE 形式导出）。

C. 验证实际传递的编译参数（重要）

* 在第 1 步的 `-v` 输出中查找 `Scheduler.cppm` 的编译行：

  * MSVC 期望看到诸如 `/module:reference <path-to-Threading.pcm>` 或者 `/AI <path-containing-pcm>`。
  * 如果没有 module:reference，说明 CMake 没把 BMI 传递给编译器。需要调整 target_link 或 file_set 配置直到编译行包含它。

D. 若 CMake 能见到 BMI 但仍不合并——清理并强制重建 BMI：

* 删除缓存/旧 BMI 然后全量重建：

  ```powershell
  rd /s /q Build\CMakeFiles
  rd /s /q Build\*Module*   # 或删除编译器生成的 .pcm/.ifc/.gcm 等
  cmake --build Build --config Debug
  ```

  许多模块问题是旧 BMI 导致的可见集不一致，**干净重建**常能解决。

E. 临时诊断代码（快速定位“导入生效/不生效”）
在 `Scheduler.cppm` 顶部临时放：

```cpp
import Prm.Threading;   // 或 import Prm; — 按实际 module 名称
static_assert(sizeof(Prm::ThreadHandle) > 0, "ThreadHandle not visible");
```

如果编译错误提示仍为“不是 Prm 的成员”，说明编译器确实看到了 Prm（名字空间/模块）但该导出集没有被合并 → 再次回到步骤 A/B/C。

补充可能的边缘原因（列出以排除）

* Threading 实际导出为模块分区（`export module Prm:Threading;`）而你 `import Prm.Threading;`（分区名写法不同），注意分区语法。
* Threading target 被当成 PRIVATE 链接到某中间目标，Job 并未直接获得它的模块引用（虽然你用 add_dependencies，但 link_libraries 必须是 PUBLIC/INTERFACE 才传播编译器参数）。
* 不同编译器/工具链对 BMI 路径传递策略不同 —— 确认 MSVC 的 `/module:reference` 已被传递（最关键）。

最后给出你可以立刻执行的三条命令（按顺序）

1. 查看 Job 编译行是否带 module:reference：

   ```
   cmake --build Build --target Job --config Debug -v
   ```
2. 如果没有，检查 Threading 的 target_sources/file_set 是否正确（打开 `Primitive/Threading/CMakeLists.txt`，确认 interface .ixx 被列入 `FILE_SET CXX_MODULES` 或 target_sources）。
3. 清理 BMI 并重建：删除 Build 下的 BMI 文件 / CMakeFiles，然后 `cmake --build Build --config Debug`。

若你把 `cmake --build ... -v` 的那条 `Scheduler.cppm` 编译命令粘给我（只需那一行），我能立刻读出是不是缺少 `/module:reference` 并给出精确 CMake 修补（例如要把哪一个 target 改为 `PUBLIC`、或把哪个 file_set 加到哪里）。
