重构完成，现在完成了闭环但是还没有引入UI，先执行去标准库化，然后建立CICD用以规范代码质量，然后再说UI的事情。
1是否需要增强我们的Vector和String，如果不需要增强而是增加适配API就算了，还是重构消费端吧
2现在分析我们如何重构Cap.Config 和 Sys.RHI的去标准库化
3以及‘SystemMemoryResource :  malloc 的包装’的重构。
4以及代码实现位置修改和质量的一些重构

### **1. 容器增强策略：适配 API vs 重构消费端**

**结论：不要为了模仿 `std` 而过度增强，但必须实现核心 Trait。**

完全复刻 `std::vec::Vec` 的所有 API 是巨大的时间黑洞，且没必要。但是，如果 API 太简陋（例如只能 `push` 不能迭代），会导致消费端代码（Sim/Sys）极其丑陋且难以维护。

**建议策略：**

1.  **核心 Trait 必须实现**：
    *   `Deref<Target=[T]>` / `DerefMut`：这是最重要的。只要实现了这个，你的 `Cap.Vector` 就能自动获得切片（Slice）的所有功能（`iter()`, `len()`, `is_empty()`, `sort()`, `binary_search()` 等）。**这是性价比最高的增强。**
    *   `Index` / `IndexMut`：支持 `v[i]` 语法。
    *   `IntoIterator`：支持 `for x in v` 语法。

2.  **消费端重构**：
    *   **拒绝**：`v.retain(|x| ...)` 或 `v.drain(...)` 这种复杂的辅助函数。如果业务层需要，让他们手写循环或 swap_remove。
    *   **强制**：消费端必须习惯显式传递 `Allocator`。例如 `Vector::new(alloc)` 而不是 `Vec::new()`。这是架构约束，不能妥协。

**行动：** 给 `Cap.Vector` 和 `CapString` 实现 `Deref`，这能瞬间解决 90% 的易用性问题。

---

### **2. `Cap.Config` 和 `Sys.RHI` 的去标准库化 (De-std)**

这两个模块是 `std` 污染的重灾区。

#### **A. `Cap.Config` (INI/JSON 解析)**
目前的实现可能使用了 `String` 和 `File::open`。

*   **IO 改造**：
    *   使用 `Sys.VFS` 或 `Prm.File` 读取文件内容到 `Cap.Vector<u8>` 缓冲区。
*   **解析改造 (Zero-Copy)**：
    *   **核心思想**：配置文件的解析结果不需要拥有字符串的所有权，它只需要持有原始缓冲区的**切片引用 (`&str`)**。
    *   **数据结构**：
        ```rust
        pub struct Config<'a> {
            // 原始文件内容，由外部 Allocator 管理
            raw_buffer: Vector<'a, u8>, 
            // 键值对只存引用，指向 raw_buffer 内部
            entries: HashMap<&'a str, &'a str>, 
        }
        ```
    *   这样你就不需要分配成百上千个细碎的 `String` 对象，极大减轻内存压力。

#### **B. `Sys.RHI` (资源与后端)**
RHI 经常需要 `Vec<u8>` 来做 Staging Buffer，以及 `CString` 传给 Vulkan。

*   **Staging Buffer 改造**：
    *   不要用 `Vec<u8>`。在 `Sys.RHI` 中引入一个 **`ScratchAllocator` (线性分配器)**。
    *   当需要上传模型数据时，从 `ScratchAllocator` 分配一块临时内存，用完即弃（每帧重置）。
*   **CString 改造**：
    *   Vulkan 需要 `*const i8` (null-terminated)。
    *   不要用 `std::ffi::CString`。
    *   写一个辅助函数，将 `&str` 拷贝到栈上的 `[u8; 256]` 数组或 `Cap.Vector<u8>` 中，并在末尾补 `\0`。
*   **环境变量**：
    *   移除 `std::env::var`。改为在 `Engine.App` 启动时解析命令行参数，通过 `RhiDesc` 结构体传给 `Device::new`。

---

### **3. `SystemMemoryResource` 的重构：摆脱 malloc**

目前的 `SystemMemoryResource` 在非 Windows 平台可能只是 `std::alloc` 的包装。

**目标**：直接对接 OS 虚拟内存 API，实现真正的“完全控制”。

**重构方案：**

1.  **分层设计**：
    *   **Layer 0 (OS Page)**: `Prm.Memory` (已有的 `vm_reserve`, `vm_commit`)。这是大块内存（64KB/2MB）的来源。
    *   **Layer 1 (Heap)**: `SystemMemoryResource` 不应该直接调用 `vm_commit` 来分配 32 字节的小对象（这会浪费大量页内存）。它需要一个**堆算法**。

2.  **实现路径**：
    *   **路径 A (硬核自研)**: 在 `SystemMemoryResource` 内部实现一个 **TLSF (Two-Level Segregated Fit)** 或 **Free List** 算法。它向 OS 申请大页，然后切分给上层。
    *   **路径 B (实用主义 - 推荐)**:
        *   在 Windows 上，直接封装 **`HeapAlloc` / `HeapCreate`** (Win32 API)。这是操作系统提供的、经过高度优化的堆分配器，比 `malloc` 更底层，且完全绕过 CRT。
        *   在 Linux 上，使用 `mmap` 实现一个简单的 Slab 分配器，或者暂时链接 `libc` 的 `malloc` 但通过 FFI 调用（不走 Rust `std::alloc`）。

**建议**：先走 **路径 B (Windows HeapAlloc)**。这符合你“Prm 层是对 OS API 的零成本抽象”的定义。

```rust
// Prm.Memory.Windows
pub fn heap_alloc(h: HeapHandle, size: usize) -> *mut c_void {
    unsafe { HeapAlloc(h, 0, size) }
}
```

---

### **4. 代码位置与质量重构**

既然要建立 CI/CD，代码结构必须规范化。

#### **A. 目录结构调整**
目前的 `Impl` 文件夹混在 `API` 旁边，有些混乱。建议采用 **Workspace 模式** 或 **Feature 门控**。

*   **建议结构**：
    ```text
    Foundation/Prm/File/
    ├── Cargo.toml
    ├── src/
    │   ├── lib.rs           # 对外 API (Trait / Functions)
    │   ├── windows.rs       # #[cfg(windows)] 实现
    │   └── linux.rs         # #[cfg(linux)] 实现
    ```
    *   不要把实现藏在 `Impl/Windows/Ops.rs` 这种深层目录里，直接放在 `src/platform/windows.rs` 更符合 Rust 惯例。

#### **B. 质量重构 (Quality of Life)**

1.  **统一错误处理**：
    *   目前的 `Result<T, ()>` 或 `Option<T>` 信息量太少。
    *   在 `Foundation/Lang` 中定义一个全局的 `Status` 枚举或 `Error` trait，让所有模块返回统一的错误码。

2.  **安全性标记**：
    *   你的代码里有很多 `unsafe`。
    *   **重构规则**：对于每一个 `unsafe` 块，必须加注释 `// SAFETY: ...` 解释为什么这里是安全的（例如：指针不为空、内存已对齐）。这是 CI 代码审查的重点。

3.  **模块可见性**：
    *   检查所有的 `pub`。很多内部 helper 函数应该是 `pub(crate)` 而不是 `pub`。收缩 API 表面积。

---

### **总结：执行清单**

1.  **Cap.Containers**: 实现 `Deref<Target=[T]>`，不增加新 API。
2.  **Cap.Config**: 重写为 Zero-Copy 解析，持有 `&str` 而非 `String`。
3.  **Sys.RHI**: 引入 `ScratchAllocator` 替代 `Vec<u8>`；移除 `std::env`。
4.  **Prm.Memory**: 在 Windows 下改用 `HeapAlloc` 替代 `malloc` 包装。
5.  **CI**: 配置 `cargo check --no-default-features` 确保没有隐式链接 `std`。

完成这些后，你的引擎内核将变得像手术刀一样纯净、锋利。